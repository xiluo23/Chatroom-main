<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatroom Web Client</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; background-color: #f0f2f5; height: 90vh; display: flex; flex-direction: column; }
        h2 { color: #333; text-align: center; margin-bottom: 10px; }
        
        /* Layout */
        .main-container { display: flex; flex: 1; gap: 20px; min-height: 0; }
        .sidebar { width: 250px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; padding: 15px; }
        .chat-area { flex: 1; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; padding: 15px; }
        
        /* Components */
        #chat-box { flex: 1; overflow-y: auto; margin-bottom: 15px; padding: 10px; border: 1px solid #eee; border-radius: 4px; background: #fafafa; }
        .message { margin-bottom: 8px; padding: 8px 12px; border-radius: 12px; max-width: 80%; word-wrap: break-word; font-size: 14px; line-height: 1.4; }
        .message.system { color: #666; font-style: italic; background-color: #e9ecef; font-size: 0.85em; max-width: 100%; text-align: center; }
        .message.self { background-color: #007bff; color: white; align-self: flex-end; margin-left: auto; }
        .message.other { background-color: #e9ecef; color: #333; align-self: flex-start; }
        .message.private { border: 2px solid #ffc107; }
        .message.multi { border: 2px solid #17a2b8; }
        .message-meta { font-size: 0.75em; opacity: 0.8; margin-bottom: 2px; display: block; }
        
        .user-list { flex: 1; overflow-y: auto; list-style: none; padding: 0; margin: 10px 0; }
        .user-item { padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; border-radius: 4px; display: flex; align-items: center; justify-content: space-between; }
        .user-item:hover { background-color: #f8f9fa; }
        .user-item.active { background-color: #e7f1ff; color: #007bff; font-weight: bold; }
        .user-item.broadcast { font-weight: bold; color: #28a745; }
        
        /* Checkbox style for multi-select */
        .user-select-check {
            width: 18px; height: 18px; margin-right: 10px; cursor: pointer;
        }

        .controls { display: flex; gap: 10px; margin-top: 10px; }
        input[type="text"], input[type="password"] { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px; outline: none; }
        input[type="text"]:focus { border-color: #007bff; }
        
        button { padding: 10px 20px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background 0.2s; white-space: nowrap; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.danger { background-color: #dc3545; }
        button.success { background-color: #28a745; }
        
        #auth-screen { max-width: 400px; margin: 50px auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .hidden { display: none !important; }
        
        .target-indicator { margin-bottom: 5px; font-size: 0.9em; color: #666; }
        .target-indicator span { font-weight: bold; color: #007bff; }
    </style>
</head>
<body>
    <h2>Chatroom Web Client</h2>
    
    <!-- Connection / Auth Screen -->
    <div id="auth-screen">
        <div id="connection-status" style="text-align: center; margin-bottom: 20px; color: #666;">
            çŠ¶æ€: <span id="status-text">æœªè¿æ¥</span>
        </div>
        
        <div id="auth-forms" class="hidden">
            <div class="controls">
                <input type="text" id="username" placeholder="ç”¨æˆ·å">
            </div>
            <div class="controls" style="margin-top: 10px;">
                <input type="password" id="password" placeholder="å¯†ç ">
            </div>
            <div class="controls" style="margin-top: 20px;">
                <button onclick="doLogin()" style="flex: 1;">ç™»å½•</button>
                <button onclick="doRegister()" class="success" style="flex: 1;">æ³¨å†Œ</button>
            </div>
        </div>
        
        <div id="connect-btn-container" style="text-align: center;">
             <button onclick="connect()" id="btn-connect">è¿æ¥æœåŠ¡å™¨</button>
        </div>
    </div>

    <!-- Main Chat Screen -->
    <div id="chat-screen" class="main-container hidden">
        <!-- Sidebar: User List -->
        <div class="sidebar">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <strong>åœ¨çº¿ç”¨æˆ·</strong>
                <div>
                    <button onclick="send('show_history')" style="padding: 4px 8px; font-size: 12px; margin-right: 5px;" class="secondary">å†å²</button>
                    <button onclick="send('show_online_user')" style="padding: 4px 8px; font-size: 12px;" class="secondary">åˆ·æ–°</button>
                </div>
            </div>
            <ul class="user-list" id="user-list">
                <li class="user-item broadcast active" onclick="selectTarget(null)">
                    <span>ğŸ“¢ ç¾¤å‘å¹¿æ’­ (æ‰€æœ‰äºº)</span>
                </li>
                <!-- Users will be populated here -->
            </ul>
            <div style="margin-top: auto; border-top: 1px solid #eee; padding-top: 10px;">
                <div style="margin-bottom: 5px;">å½“å‰ç”¨æˆ·: <strong id="current-user-display">-</strong></div>
                <button onclick="logout()" class="danger" style="width: 100%;">é€€å‡ºç™»å½•</button>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="chat-area">
            <div id="chat-box"></div>
            
            <div class="target-indicator">
                å‘é€ç»™: <span id="target-display">æ‰€æœ‰äºº</span>
            </div>
            
            <div class="controls">
                <input type="text" id="message-input" placeholder="è¾“å…¥æ¶ˆæ¯..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()">å‘é€</button>
            </div>
        </div>
    </div>

    <script>
        let ws;
        let currentUser = "";
        let selectedUsers = new Set(); // Stores usernames. Empty means broadcast/none depending on context, but let's be explicit.
        let isBroadcast = true; // Default to broadcast
        let heartbeatInterval = null;
        
        function connect() {
            const btn = document.getElementById('btn-connect');
            const status = document.getElementById('status-text');
            
            status.innerText = "è¿æ¥ä¸­...";
            status.style.color = "orange";
            btn.disabled = true;

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            const wsUrl = `${protocol}//${host}`;
            
            console.log("Connecting to:", wsUrl);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                status.innerText = "å·²è¿æ¥";
                status.style.color = "green";
                document.getElementById('connect-btn-container').classList.add('hidden');
                document.getElementById('auth-forms').classList.remove('hidden');
                appendSystemMessage("å·²è¿æ¥åˆ°æœåŠ¡å™¨");
            };

            ws.onmessage = (event) => {
                const msg = event.data;
                console.log("RX:", msg);
                parseMessage(msg);
            };

            ws.onclose = () => {
                status.innerText = "å·²æ–­å¼€";
                status.style.color = "red";
                stopHeartbeat();
                resetUI();
            };
            
            ws.onerror = (err) => {
                status.innerText = "è¿æ¥é”™è¯¯";
                status.style.color = "red";
                btn.disabled = false;
            };
        }

        function resetUI() {
            document.getElementById('auth-screen').classList.remove('hidden');
            document.getElementById('chat-screen').classList.add('hidden');
            document.getElementById('connect-btn-container').classList.remove('hidden');
            document.getElementById('auth-forms').classList.add('hidden');
            document.getElementById('btn-connect').disabled = false;
            document.getElementById('chat-box').innerHTML = '';
            currentUser = "";
        }

        function parseMessage(msg) {
            // Protocol: cmd|code|payload
            // Some payloads might contain | so we limit split
            const firstPipe = msg.indexOf('|');
            if (firstPipe === -1) { appendMessage("Unknown", msg, "system"); return; }
            
            const cmd = msg.substring(0, firstPipe);
            const rest = msg.substring(firstPipe + 1);
            
            const secondPipe = rest.indexOf('|');
            let code, payload;
            
            if (secondPipe === -1) {
                code = rest;
                payload = "";
            } else {
                code = rest.substring(0, secondPipe);
                payload = rest.substring(secondPipe + 1);
            }

            // Handle Commands
            if (cmd === 'sign_in') {
                if (code === '1') {
                    currentUser = document.getElementById('username').value;
                    document.getElementById('current-user-display').innerText = currentUser;
                    document.getElementById('auth-screen').classList.add('hidden');
                    document.getElementById('chat-screen').classList.remove('hidden');
                    appendSystemMessage("ç™»å½•æˆåŠŸ");
                    startHeartbeat();
                    send('show_online_user'); // Auto refresh list
                } else {
                    alert("ç™»å½•å¤±è´¥: " + payload);
                }
            } else if (cmd === 'sign_up') {
                if (code === '1') alert("æ³¨å†ŒæˆåŠŸï¼Œè¯·ç™»å½•");
                else alert("æ³¨å†Œå¤±è´¥: " + payload);
            } else if (cmd === 'show_online_user') {
                if (code === '1') updateUserList(payload);
            } else if (cmd === 'broadcast_chat') {
                if (code === '2') {
                    // Sent success confirmation
                    // Don't need to do much, maybe show own message if not handled locally
                } else if (code === '1') {
                    // Incoming broadcast: sender;content
                    // Note: payload might contain ; in content, so split by first ;
                    const sepIndex = payload.indexOf(';');
                    if (sepIndex !== -1) {
                        const sender = payload.substring(0, sepIndex);
                        const content = payload.substring(sepIndex + 1);
                        appendMessage(sender, content, "other", "Broadcast");
                    }
                }
            } else if (cmd === 'single_chat') {
                if (code === '2') {
                    // Sent success
                } else if (code === '1') {
                    // Incoming private: sender;content
                    const sepIndex = payload.indexOf(';');
                    if (sepIndex !== -1) {
                        const sender = payload.substring(0, sepIndex);
                        const content = payload.substring(sepIndex + 1);
                        appendMessage(sender, content, "other", "Private");
                    }
                }
            } else if (cmd === 'multi_chat') {
                 if (code === '2') {
                    const sepIndex = payload.indexOf(';');
                    if (sepIndex !== -1) {
                        const sender = payload.substring(0, sepIndex);
                        const content = payload.substring(sepIndex + 1);
                        appendMessage(sender, content, "other", "Multi");
                    }
                 }
            } else if (cmd === 'show_history') {
                if (code === '1') {
                    // Payload: Sender Receiver Date Time GroupType Content\n...
                    // Server returns newest first (DESC limit 50).
                    const lines = payload.split('\n');
                    const seen = new Set();
                    const uniqueMsgs = [];

                    lines.forEach(line => {
                        line = line.trim();
                        if (!line) return;
                        
                        const parts = line.split(' ');
                        if (parts.length >= 6) {
                            const sender = parts[0];
                            const receiver = parts[1];
                            const date = parts[2];
                            const time = parts[3];
                            const type = parts[4];
                            const content = parts.slice(5).join(' ');
                            
                            // Deduplicate broadcast fan-out
                            let key = "";
                            if (type === 'broadcast') {
                                key = `broadcast|${sender}|${date}|${time}|${content}`;
                            } else {
                                key = `single|${sender}|${receiver}|${date}|${time}|${content}`;
                            }

                            if (!seen.has(key)) {
                                seen.add(key);
                                uniqueMsgs.push({sender, receiver, date, time, type, content});
                            }
                        }
                    });

                    // Reverse to show oldest first
                    uniqueMsgs.reverse();

                    if (uniqueMsgs.length > 0) {
                        appendSystemMessage("--- å†å²è®°å½•å¼€å§‹ ---");
                        uniqueMsgs.forEach(msg => {
                            let msgType = "other";
                            let tag = "History";
                            
                            if (msg.sender === currentUser) {
                                msgType = "self";
                            }
                            
                            if (msg.type === 'single') {
                                if (msg.sender === currentUser) {
                                    tag = `To: ${msg.receiver}`;
                                } else {
                                    tag = "Private";
                                }
                            } else if (msg.type === 'broadcast') {
                                tag = "Broadcast";
                            }

                            appendMessage(msg.sender, msg.content, msgType, `${tag} ${msg.date} ${msg.time}`);
                        });
                        appendSystemMessage("--- å†å²è®°å½•ç»“æŸ ---");
                    } else {
                         appendSystemMessage("æ²¡æœ‰æ›´å¤šå†å²è®°å½•");
                    }
                }
            } else if (cmd === 'chat_unread') {
                if (code === '1') {
                    // Payload is newline separated list of: Sender Date Time Content
                    // Example: user1 2023-10-27 10:00:00 Hello World 
                    const lines = payload.split('\n');
                    let count = 0;
                    lines.forEach(line => {
                        line = line.trim();
                        if (!line) return;
                        
                        // Parse: Sender Date Time Content
                        // [0]=Sender, [1]=Date, [2]=Time, [3+] = Content
                        const parts = line.split(' ');
                        if (parts.length >= 4) {
                            const sender = parts[0];
                            const date = parts[1];
                            const time = parts[2];
                            const content = parts.slice(3).join(' ');
                            
                            appendMessage(sender, content, "other", `Unread ${date} ${time}`);
                            count++;
                        }
                    });
                    if (count > 0) {
                        appendSystemMessage(`æ”¶åˆ° ${count} æ¡ç¦»çº¿æ¶ˆæ¯`);
                    }
                }
            } else if (cmd === 'heartbeat') {
                // Heartbeat response, ignore
            } else {
                // Unknown or generic
                console.log("Unhandled:", cmd, code, payload);
            }
        }

        function updateUserList(data) {
            const list = document.getElementById('user-list');
            list.innerHTML = ''; // Clear list
            
            // Broadcast item
            const liBroadcast = document.createElement('li');
            liBroadcast.className = `user-item broadcast ${isBroadcast ? 'active' : ''}`;
            liBroadcast.onclick = () => selectBroadcast();
            liBroadcast.innerHTML = `<span>ğŸ“¢ ç¾¤å‘å¹¿æ’­ (æ‰€æœ‰äºº)</span>`;
            list.appendChild(liBroadcast);
            
            // Data format: user1 \nuser2 ...
            const users = data.split(/[ \n]+/).filter(u => u.trim() !== "");
            
            users.forEach(user => {
                if (user === currentUser) return; // Don't list self
                
                const li = document.createElement('li');
                li.className = `user-item ${selectedUsers.has(user) ? 'active' : ''}`;
                li.onclick = (e) => toggleUser(user);
                li.setAttribute('data-username', user);
                
                const checkMark = selectedUsers.has(user) ? "âœ… " : "â¬œ ";
                li.innerHTML = `<span>${checkMark}${user}</span>`;
                list.appendChild(li);
            });
            
            updateTargetDisplay();
        }

        function selectBroadcast() {
            isBroadcast = true;
            selectedUsers.clear();
            refreshUserListUI(); // We need to re-render to update checkmarks
        }

        function toggleUser(user) {
            if (isBroadcast) {
                isBroadcast = false; // Switch off broadcast if selecting a user
            }
            
            if (selectedUsers.has(user)) {
                selectedUsers.delete(user);
                if (selectedUsers.size === 0) {
                    isBroadcast = true; // Revert to broadcast if last user deselected? Or stay in "no selection" mode?
                    // Let's default back to broadcast for better UX
                }
            } else {
                selectedUsers.add(user);
            }
            refreshUserListUI();
        }
        
        // Helper to refresh UI without full list reload
        function refreshUserListUI() {
             const list = document.getElementById('user-list');
             // Update Broadcast Item (first child)
             const liBroadcast = list.firstElementChild;
             if (liBroadcast) {
                 liBroadcast.className = `user-item broadcast ${isBroadcast ? 'active' : ''}`;
             }
             
             // Update User Items
             // Skip first child
             let index = 1;
             const items = list.children;
             // We need to match items to users. 
             // Ideally we should store the username in a data attribute.
             // But since we just rebuilt the list in updateUserList, we might not have data attributes unless we add them.
             // Let's rely on innerText parsing or better yet, just request a refresh if we had the full list data.
             // Since we don't store the full user list globally, let's just trigger 'show_online_user' to refresh?
             // No, that causes network traffic. Let's just modify the DOM based on text content.
             
             for (let i = 1; i < items.length; i++) {
                 const item = items[i];
                 // Text content includes the checkmark emoji, need to strip it or read raw user name
                 // Let's fix updateUserList to use data attributes for robustness.
                 const user = item.getAttribute('data-username');
                 if (user) {
                     const isSelected = selectedUsers.has(user);
                     item.className = `user-item ${isSelected ? 'active' : ''}`;
                     const checkMark = isSelected ? "âœ… " : "â¬œ ";
                     item.innerHTML = `<span>${checkMark}${user}</span>`;
                 }
             }
             
             updateTargetDisplay();
        }

        // We need to patch updateUserList to add data-username
        // Let's overwrite updateUserList again with the robust version.
        
        function updateTargetDisplay() {
            const display = document.getElementById('target-display');
            if (isBroadcast) {
                display.innerText = "æ‰€æœ‰äºº (å¹¿æ’­)";
            } else {
                const users = Array.from(selectedUsers);
                if (users.length === 0) {
                     display.innerText = "æ‰€æœ‰äºº (å¹¿æ’­)"; // Fallback
                } else if (users.length === 1) {
                    display.innerText = users[0];
                } else {
                    display.innerText = `${users.length} äºº: ${users.join(", ")}`;
                }
            }
        }

        function appendMessage(sender, text, type, tag) {
            const box = document.getElementById('chat-box');
            const div = document.createElement('div');
            div.className = `message ${type}`;
            if (tag === "Private") div.classList.add('private');
            
            const meta = document.createElement('span');
            meta.className = 'message-meta';
            meta.innerText = tag ? `[${tag}] ${sender}` : sender;
            
            const content = document.createElement('div');
            content.innerText = text;
            
            div.appendChild(meta);
            div.appendChild(content);
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }
        
        function appendSystemMessage(text) {
            const box = document.getElementById('chat-box');
            const div = document.createElement('div');
            div.className = 'message system';
            div.innerText = text;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }

        function doLogin() {
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            if(!user || !pass) return alert("è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ");
            send(`sign_in|${user}|${pass}`);
        }

        function doRegister() {
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            if(!user || !pass) return alert("è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ");
            send(`sign_up|${user}|${pass}`);
        }
        
        function logout() {
            send("q"); // Send quit command
            stopHeartbeat();
            resetUI();
            if (ws) ws.close();
        }

        function startHeartbeat() {
            stopHeartbeat(); // Clear any existing
            // Send heartbeat every 15 seconds (server timeout is 40s)
            heartbeatInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    send("heartbeat|");
                }
            }, 15000);
            console.log("Heartbeat started");
        }

        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
                console.log("Heartbeat stopped");
            }
        }

        function sendMessage() {
            const input = document.getElementById('message-input');
            const text = input.value;
            if (!text) return;
            
            if (isBroadcast) {
                // Broadcast
                send(`broadcast_chat|${text}`);
                appendMessage("æˆ‘", text, "self", "Broadcast");
            } else {
                const users = Array.from(selectedUsers);
                if (users.length === 0) {
                     // Should act as broadcast if nothing selected? Or prompt?
                     // Logic in toggleUser sets isBroadcast=true if empty, so this might not be reached easily.
                     // But just in case:
                     send(`broadcast_chat|${text}`);
                     appendMessage("æˆ‘", text, "self", "Broadcast");
                } else if (users.length === 1) {
                    // Single Chat
                    const target = users[0];
                    send(`single_chat|${target}|${text}`);
                    appendMessage("æˆ‘", text, "self", "Private -> " + target);
                } else {
                    // Multi Chat
                    // Format: multi_chat|user1 user2|content
                    const userListStr = users.join(' ');
                    send(`multi_chat|${userListStr}|${text}`);
                    appendMessage("æˆ‘", text, "self", "Multi -> " + users.join(', '));
                }
            }
            input.value = '';
        }

        function send(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(data);
            } else {
                alert("æœªè¿æ¥æœåŠ¡å™¨");
            }
        }

        function handleKeyPress(e) {
            if (e.key === 'Enter') sendMessage();
        }
    </script>
</body>
</html>
